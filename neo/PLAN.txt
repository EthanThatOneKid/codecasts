Note: For today's episode, I will attempt
      to complete all of the components of
      the interpreter, but if I cannot, I
      will continue this checklist into
      a later episode.

What am I doing?!
      Well, I am going to write my neo interpreter
      in Deno, but I will be allowing for backwards-
      compatibility by publishing my module as an
      npm package post-bundle.

Development Steps
* [ ] Rename the current neo repository to neo-cli
* [ ] Create a new neo repository
* Install prerequisites:
  * [ ] Install npm: `https://nodejs.org/en/`
  * [ ] Install deno: `https://github.com/denoland/deno_install`
  * [ ] Install denon: `deno install --allow-read --allow-run --allow-write --allow-net -f --unstable https://deno.land/x/denon@v2.2.1/denon.ts`
* Initialize package: `npm init`
  * [ ] Rename package: `"name": "@ethanthatonekid/neo"`
  * [ ] Edit description: `"description": "Interpreter for Neo, a scripting language for web automation."`
  * [ ] Edit homepage: `"homepage": "https://neolang.dev/"`
  * [ ] Edit author: `"author": "EthanThatOneKid <ethan.r.davidson@gmail.com> (http://ethandavidson.com/)"`
  * [ ] Edit module entry: `"main": "dist/mod.js"` (Note: Make sure this is the correct entry point post-initial-bundle)
  * [ ] Create npm package.json with scripts:
    * `"doc": "deno doc mod.ts --json"`
    * `"dev": "denon test"`
    * `"build": "deno bundle mod.ts dist"`
    * `"publish": "npm publish --access public"`
* Create the neo interpretter
  * [ ] Lexer (Creates a list of tokens / ignores comments)
  * [ ] Parser (Builds recursive syntax tree; store line number for error tracing)
  * [ ] Compiler (Creates rules by determining statements)
  * [ ] Bytecode (Adding constants to the stack and emitting operations)
  * [ ] Object Model (Declare object types and their operations; asserts type-errors)
  * [ ] Interpreter (Runs bytecode from start to finish)